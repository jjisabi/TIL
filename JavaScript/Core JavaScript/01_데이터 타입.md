# `데이터 타입`
*목표1. 자바스크립트가 데이터를 처리하는 과정 이해*<br>
*목표2. 기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유 이해*<br><br>

### 1. 데이터 타입의 종류
<hr>

**1) 기본형** (Primitive data type)
- Object를 제외한 모든 타입은 언어의 최하위 수준에서 직접 표현되는 변경 불가능한 *`불변 값`* 이며 pass-by-value(값에 의한 전달) 방식이다.

- number, string, boolean, null, undefined + Symbol

<br>

**2) 참조형** (Object type, Reference type)
- JavaScript는 객체 기반의 스크립트 언어로써 JavaScript를 이루고 있는 거의 모든 것이 객체이다.

- 주로 key-value 쌍 데이터 저장하며 여러 개의 속성을 저장할 수 있다. 

- 객체는 유일한 *`변경 가능한 값`* 이며 pass-by-reference 방식이다.

- object (Array, Function, Date, RegExp + Map, WeakMap, Set, WeakSet)

<br><br>

### 2. 데이터 타입에 관한 배경지식
<hr>

#### `1-2-1 메모리와 데이터`
메모리는 많은 비트들로 구성되어 있고, 각 비트는 고유한 식별자를 통해 위치를 확인할 수 있다. 
비트는 다시 바이트 단위로 묶고(8bit = 1byte) 비트가 고유한 식별자를 가지는 것 처럼 **바이트도 식별자를 가진다. 이를 `메모리 주솟값`이라고 하며 이를 통해 위치를 파악하고 구분한다.
이것이 데이터를 저장하는 방법이며 메모리 주솟값을 통해 서로 구분하고 연결한다.**
C/C++, 자바 등의 정적 타입 언어와 달리 **자바스크립트는 동적타입이 있는 동적언어**이다. (자바스크립트의 변수는 어떤 특정타입과 연결되지 않으며 모든 타입의 값으로 할당 및 재할당이 가능하다.)

#### `1-2-2 식별자와 변수`
- 변수: 변할 수 있는 수(데이터), **변경 가능한 데이터가 담길 수 있는 공간**<br>
- 식별자: 데이터를 식별하는 데 사용하는 이름 (변수명)

<br>


### 3. 변수 선언과 데이터 할당
<hr>

#### `1-3-1 변수 선언`
변수 선언 과정: 메모리에서 비어있는 공간(ex.100번지)을 확보하고 해당 공간의 이름(식별자)을 a라고 지정한다.
 ```
 var a; // 변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.
 ```
 

#### `1-3-2 데이터 할당`
데이터 할당 과정: a라는 이름을 가진 주소를 검색한 후 데이터를 저장하기 위한 별도의 메모리 공간을 확보하여 문자열 'abc'를 저장하고 그 주소를 변수 영역에 저장한다.
 ```
 var a;         // 변수 a 선언
 a = 'abc';     // 변수 a에 데이터 할당
 var a = 'abc'; // 변수 선언과 할당을 동시에
 ```
<br>

**데이터 할당에 대한 메모리 영역의 변화**<br>

1 )변수 영역에서 빈 공간(@100번지)을 확보한다.<br>
2 )확보한 공간의 식별자를 a로 지정한다.<br>
3 )데이터 영역의 빈 공간(@200번지)에 문자열 'abc'를 저장한다.<br>
4 )변수 영역에서 a라는 식별자를 검색한다(@100).<br>
5 )앞서 저장한 문자열의 주소(@200)를 @100의 공간에 대입한다.<br>

=> 데이터 변환 자유롭게하여 메모리 효율적으로 관리하기 위해서 변수영역과 데이터 영역을 나눈다.
기존 문자열에 어떤 변환을 가하면 `새로` 만들어 별도의 공간에 저장한다.<br><br>
*ex) 문자열 'abc'에 'de'를 추가하면 @200에 문자열 값을 변경하는 것이 아니라 @201에 새로 'abcde'를 만들고 @100 공간에 새로운 주소 @201을 연결한다.*

<br><br>

### 4. 기본형 데이터와 참조형 데이터
<hr>

#### `1-4-1 불변값`
 ```
 var a = 'abc';
 a = a + 'def';

 var b = 5;
 var c = 5;
 b = 7;
 ```

 1 )변수 a에 문자열 'abc'의 주소를 저장한다.<br>
 2 )변수 a에 문자열 'abcdef'의 주소를 저장한다. (이때 'abc'와 'abcdef'는 완전히 별개의 데이터이다.)<br>
 3 )데이터 영역에 숫자 5가 있는 지 찾고 없으면 데이터 공간을 만들어 5를 만들고 해당 데이터 공간의 주솟값을 변수 b에 저장한다.<br>
 4 )데이터 영역에 숫자 5가 있으므로 해당 공간의 주솟값을 변수 c에 저장한다.<br>
 5 )새로 만든 7 데이터 공간의 주솟값을 변수 b에 저장한다. (이때 기존에 저장된 5자체를 7로 바꾸는 것이 아니다.)<br><br>
 **=> 이처럼 변경은 새로 만드는 동작을 통해서만 이루어지고 변경할 수 없다. 이를 `불변값의 성질`이라고 한다.**

<br>

#### `1-4-2 가변값`
```
var obj1 = {
    a: 1,
    b: 'bbb'
};
```
1 ) 변수 영역의 빈 공간 @1002를 확보하고 주소의 이름을 obj1으로 지정한다.<br>
2 ) 임의의 데이터 영역 @5001에 데이터 저장 시 여러 개의 속성으로 이루어진 데이터 그룹이므로 해당 속성을 저장하기 위해 별도의 변수 영역을 마련한다. 그 영역의 주소(@7103)를 @5001에 저장한다.<br>
3 ) @7103과 @7104에 각각 a와 b라는 속성명을 지정한다.<br>
4 ) 데이터 영역에서 숫자 1을 검색하여 검색 결과가 없으므로 임의로 @5003에 저장하고 해당 주소를 @7103에 저장한다. 문자열 'bbb'도 마찬가지의 과정을 거친다. <br><br>
 **=>기본형 데이터와의 차이는 객체의 변수(속성) 영역이 별도로 존재한다는 점이다. `변수에는 다른 값을 대입할 수 있으므로 참조형 데이터는 가변값`이다라고 한다.**


<br>

#### `1-4-3 변수 복사 비교`
**1) 변수 복사 이후 값 변경 - 객체의 프로퍼티 변경 시**
```
var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15
obj2.c = 20;
```
기본형 데이터를 복사한 변수 b의 값을 바꿨을 때 **변수 a와 b는 서로 다른 주소값을 가지는 반면, 참조형 데이터를 복사한 변수 obj2의 내부 프로퍼티의 값을 바꾸었을 때는 변수 obj1과 obj2는 같은 객체**를 바라보고 있다.
(주소값이 달라지지 않음) 기본형은 주솟값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치는 차이점이 있다.

```
a !== b
obj1 === obj2
```
<br>

**2) 변수 복사 이후 값 변경 - 객체자체를 변경했을 때**
```
var a = 10;
var b = a;

var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;

b = 15
obj2 = {c: 20, d: 'ddd'};
```
obj2에도 새로운 객체를 할당함으로써 값을 직접 변경하여 주소값이 달라졌다.

**즉, 참조형 데이터의 가변은 참조형 데이터 자체를 변경할 경우가 아니라 그 `내부의 프로퍼티`를 변경할 때만 성립한다.** 데이터 자체를 변경하고자 하면 기본형 데이터와 마찬가지로 기존 데이터는 변하지 않는다.<br><br>

### 5. 불변 객체
<hr>

#### `1-5-1 불변 객체를 만드는 간단한 방법`
예제 1-10 객체의 가변성에 따른 문제점<br>
*(바뀐 시점에 알람을 보내거나, 바뀌기 전의 정보와 바뀐 후의 정보의 차이를 가시적으로 보여줘야하는 기능 구현 시 문제 발생)*
```
var user = {
    name: 'Jaenam',
    gender: 'male'
};

var changeName = function (user, newName) {
    var newUser = user;
    newUser.name = newName;
    return newUser;
};

var user2 = changeName(user, 'Jung');

if(user !== user2){
    console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name);         //Jung Jung
console.log(user === user2);                //true
```

<br>
예제 1-11 객체의 가변성에 따른 문제점의 해결방법

```
var user = {
    name: 'Jaenam',
    gender: 'male'
};

var changeName = function (user, newName) {
    return {name: newName, gender: user.gender};
};

var user2 = changeName(user, 'Jung');

if(user !== user2){
    console.log('유저 정보가 변경되었습니다.');
}

console.log(user.name, user2.name);
console.log(user === user2);
```

#### `1-5-2 얕은 복사와 깊은 복사`
**1) 기본형** <br>
- 얕은 복사, 깊은 복사 모두 부합하나 중첩된 속성이 없기 때문에 깊은 복사는 의미가 없다.
- 값을 복사 할 때 복사된 값을 다른 메모리에 할당 하기 때문에 원래의 값과 복사된 값이 서로에게 영향을 미치지 않는다
    ```
    const a = 1;
    let b = a;

    b = 2

    console.log(a); //1
    console.log(b); //2

    // 기존 값에 영향을 끼치지 않는다.
    ```
**2) 참조형** <br>
 - 참조값은 변수가 객체의 주소를 가리키는 값이기 때문에 복사된 값(주소)이 같은 값을 가리킨다.
 - 따라서 다시 그 내부의 프로퍼티들을 복사해야 한다(깊은 복사).
    ```
    const a = { one: 1,  two: 2 };
    let b = a;
    b.one = 3;

    console.log(a); // { one: 3, two: 2 }
    console.log(b); // { one: 3, two: 2 }

    // 기존 값에 영향을 끼친다.
    ```

**3) 얕은 복사** <br>
객체의 얕은 복사는 복사본의 속성이 복사본이 만들어진 원본 객체와 같은 참조값 **(주소값)** 를 공유하는 복사이다. 한개의 객체라도 원본 객체를 참조하고 있다면 이는 얕은 복사이다. 메모리 내의 동일한 참조형 데이터의 주소를 가르키므로 사본을 바꾸면 원본도 바뀌고 원본을 바꾸면 사본도 바뀐다.
 - 중첩된 객체의 값이 아닌 최상위 속성만 복사
 - 복사본의 최상위 속성을 재할당해도 원본 객체에는 영향을 끼치지 않는다.
 - 복사본의 중첩 객체 속성을 재할당하면 원본 객체에 영향을 끼친다. 
 
 <br>

**4) 깊은 복사** <br>
객체의 깊은 복사는 복사본의 속성이 복사본이 만들어진 원본 객체와 같은 참조(메모리 내의 같은 값을 가리킴)를 공유하지 않는 복사이다. 따라서 원본이나 복사본을 변경할 때, 다른 객체가 변경되지 않는다. 참조형일 경우(중첩된 속성) 내부의 모든 객체의 값들을 찾아 전부 복사한다.
 - 원본 객체와 참조를 공유하지 않기 때문에 깊은 복사본에 변경이 있어도 원본 객체에 영향을 주지 않는다.


    -   JSON을 활용한 깊은 복사
        : 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾼다.
        ```
        var conpyObjectViaJson = function(target){
            return JSON.parse(JSON.stringify(target));
        };

        var obj = {
            a: 1,
            b: {
                c: null,
                d: [1,2],
                func1: function () {console.log(3);}
            };
            func2: function () {console.log(4);},
        };

        var obj2 = conpyObjectViaJson(obj);

        obj2.a = 3;
        obj2.b.c = 4;
        obj.b.d[1] = 3;

        console.log(obj);   //{a: 1. b:{c:null, d:[1,3], func1:f()}, func2: f()}
        console.log(obj2);  //{a: 3. b:{c:4, d:[1,2]}}
        ```

<br><br>

### 6. undefined와 null
<hr>

**1) Javascript 엔진이 undefined를 반환하는 경우 (3가지)** 

```
// (1) 값을 대입하지 않은 변수 (데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근)
var a;
console.log(a); 

// (2) 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
var obj = {a: 1};
console.log(obj.a); 
console.log(obj.b); 

// (3) return문이 없거나 호출되지 않는 함수의 실행 결과
var func = function() {};
var c = func(); 
console.log(c);
```

**2) 배열에서의 undefined, empty** <br>
- 비어있는 배열을 할당할 때는 undefined가 아닌 empty가 지정된다. <br> *(empty는 undefined조차 할당되지 않은, 정말 말 그대로 '비어 있는' 요소를 말한다.)*
  
- undefined를 할당한 배열은 모든 요소를 순회하지만 비어있는 요소는 어떤 처리도 하지않고 건너뛴다.
  
- **배열도 객체**이므로 존재하지 않는 프로퍼티에 대해 순회할 수 없다. 즉 배열의 속성인 index는 값이 존재하지 않으면 존재하지 않는 index이므로 존재하지 않는 index에 접근할 수 없으니 건너뛰게 된다. <br> *(배열도 객체와 마찬가지로 특정 인덱스에 값을 지정할 때에 공간을 확보하고 인덱스를 지정하고 데이터의 주솟값을 저장한다.)*

<br>

**3) null** <br>
 : 비어있음을 나타냄.
 
*주의할 점:
    null의 typeof는 object이다. 따라서 null인지 여부를 판별하기 위해서는 typeof대신 `동등연산자(==)`, `일치연산자(===)`와 같은 다른 방식으로 접근해야 한다.*

<br>

**4) undefined vs null** <br>
- 사용자가 명시적으로 할당하는 경우 👉🏻 **null**<br>
말 그대로 사용자가 '없음'을 표현하기 위해 대입한 값
- Javascript 엔진이 반환하는 경우 👉🏻 **undefined** <br>
Javascript 엔진은 사용자가 어떤 값을 지정할 거라고 예상했는데 하지 않은 경우에 undefined를 반환한다. *(어떤 변수에 값이 존재하지 않을 경우)*

<br>

### 7. 정리
<hr>

- 자바스크립트 데이터 타입은 크게 **1)불변값인 기본형과 2)가변값인 참조형**이 있다.

- 변수는 변경 가능한 데이터가 담기는 공간이고, 식별자는 그 변수의 이름을 말한다.

- 변수 선언 시, 메모리의 빈 공간에 식별자를 저장하고 자동으로 undefined를 할당한다.

- 기본형 데이터 할당 시, 별도의 공간에 데이터를 저장하고 해당 주소를 변수의 값에 할당한다.

- 참조형 데이터 할당 시, 내부 프로퍼티(변수)들을 위한 변수 영역을 별도 공간을 만들고 해당 주소를 변수에 연결하고 변수 영역에 각 프로퍼티의 식별자를 저장한다. 각 데이터를 별도의 공간에 저장해서 그 주소를 식별자에 연결한다.

- 가변값인 참조형 데이터를 불변값으로 사용하기 위해서는 깊은복사를 하거나 라이브러리를 사용할 수 있다.

- 없음을 나타내는 undefined는 어떤 변수에 값이 존재하지 않을 경우를 의미하고 null은 사용자가 명시적으로 없음을 표현하기 위해 대입한 값이다.


<br>
