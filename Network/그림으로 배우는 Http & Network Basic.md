## 1장 웹과 네트워크의 기본
### 1.1 웹에서 사용하는 HTTP 프로토콜
##### HTTP 프로토콜
웹에서 클라이언트에서 서버까지의 흐름을 결정하고(클라이언트-서버 통신) 웹에서 데이터를 주고 받기 위한 프로토콜

### 1.2 HTTP 등장과 성장

### 1.3 TCP/IP 프로토콜
HTTP는 TCP/IP 프로토콜에서 움직인다.<br>
##### TCP/IP
인터넷과 관련된 프로토콜을 모은 것 <br>

##### 인터넷 프로토콜 레벨(OSI 7 Layer)
- TCP/IP 통신할 때 계층을 순서대로 거쳐 통신
- 계층화 이유
  1) 변경 시 해당 계층만 변경
  2) 설계 시 해당 계층만 고려하여 설계

- HTTP: Application Layer(7)
- TCP: Transport Layer(4) 
- IP: Network Layer(3)

### 1.4 IP/TCP/DNS
- IP: 패킷을 상대방에게 전달
- TCP: 신뢰성

### 1.5 DNS
##### DNS
도메인 이름에서 IP주소를 조사하거나 반대로 조사하는 서비스 제공

### 1.6 HTTP와 IP/TCP/DNS의 관계


### 1.7 URI와 URL
URL ⊂ URI <br>
URL(Uniform Resource Locator): Resource의 위치 정보 <br>
URI(Uniform Resource Identifiers) : 스키마를 나타내는 리소스를 식별 <br>
https://www.charlezz.com/?p=44767
<br><br>
## 2장 HTTP 프로토콜
### 2.1 클라이언트-서버 통신 HTTP
- 클라이언트: 리소스 요청(Request)
- 서버: 리소스 제공(Response)

### 2.2 Request, Response
HTTP는 클라이언트로부터 Request 송신, 서버로 부터 Response 송신
- Request Message: Method, URI, Protocol Version, Header Field, Entity
- Response Message: Protocol Version, Status code, Header Field, Body

### 2.3 Stateless
HTTP는 상태를 계속 유지하지 않는 프로토콜  -> 과거의 Request, Response 정보 가지지 않음 <br>
정보를 유지할 필요가 있어짐에 따라 쿠키가 도입 됨(HTTP 통신에서도 상태를 관리할 수 있게 됨) 

### 2.4 Request URI
클라이언트가 리소스를 호출 할 때 URI를 사용하여 리소스 지정<br>
Request URI 지정 (URI를 Request URI에 포함. Host 헤더 필드에 네트워크 로케이션을 포함)

### 2.5 HTTP Method
- GET: 리소스 요청
- POST: Entity 전송
- PUT: 파일 전송
- HEAD: GET과 같은 기능이지만 메시지 바디는 X 헤더만 돌려받는다. (URI 유효성과 리소스 갱신 시간 확인하는 등의 목적)
- DELETE: 파일 삭제
- OPTIONS: 제공하고 있는 메소드 문의 -> 서버가 제공하고 있는 메소드 되돌려 줌
- TRACE: 경로 조사
- CONNECT: 프록시에 터널링 요구 (주로 SSL이나 TLS 등의 프로토콜로 암호화 된 것 터널링 시 사용)

### 2.6 메소드 지시

### 2.7 지속 연결
HTTP 통신 시 한쪽이 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.<br> TCP 연결과 종료를 반복할 필요가 없어짐에 따라 1)서버 부하가 줄고 2) 속도가 빨라진다. <br>

지속 연결은 여러 Request를 보낼 수 있도록 파이프라인화를 가능하게 한다. (HTTP pipelining) <br>
이에 따라 요청 후 응답을 기다리지 않고 다음 요청을 보낼 수 있다.<br>
파이프라인화 > 지속 연결 > 개별 연결 

### 2.8 쿠키 사용
##### 쿠키
요청과 응답에 쿠키 정보를 추가하여 클라이언트의 상태를 파악하기 위한 시스템이다. 쿠키는 서버에서 발행해서 응답값에 ‘Set-Cookie’ 헤더 필드로 송신하고 클라이언트에 저장된다.쿠키 생성 후 클라이언트는 쿠키값을 넣어 송신한다.
HTTP는 stateless 프로토콜이기 때문에 과거 상태로 현재 요청을 처리 할 수 없다.<br>
문제점: 인증이 필요한 웹 페이지에서 페이지 이동 시 마다 재차 인증해야 하는 상황이 발생하여 문제해결로서 쿠키 시스템 도입<br>
<br><br>
## 3장 HTTP 메시지
### 3.1 HTTP 메시지
##### HTTP 메시지
HTTP에서 교환하는 정보 (Request Message, Response Message)
HTTP 메시지는 헤더와 바디로 구분되고 개행 문자로 구분한다.

### 3.2 요청 메시지와 응답 메시지의 구조
메시지 헤더, 개행문자, 메시지 바디
- Request Message Heder: 리퀘스트 라인(리퀘스트에 사용되는 메소드, URI, HTTP 버전), 리퀘스트 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드
- Response Message Heder: 상태라인(리스폰스 결과를 나타내는 상태코드와 설명, HTTP 버전), 리스폰스 헤더 필드, 일반 헤더 필드, 엔티티 헤더 필드


### 3.3 Encoding
##### Encoding
데이터 전송 시 전송 효율을을 높이기 위해 인코딩(변환) 실시
- 메시지: HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성된다.
- 엔티티: 요청과 응답의 페이로드(부가물)로 전송되는 정보로 엔티티 헤더와 바디로 구성된다.
- HTTP 메시지 바디의 역할: 요청과 응답에 관한 엔티티 바디를 운반하는 일 담당
전송 코딩이 적용된 경우, 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다.

- 콘텐츠 코딩: 엔티티에 적용하는 인코딩이며 엔티티 정보는 유지한 채 압축해서 보내는 코딩. 수신한 클라이언트 측에서 디코딩한다. ex) gzip(GNU zip), compress(UNIX 표준 압축), deflate(zlib), identity(인코딩 없음)

- 청크 전송 코딩: 사이즈가 큰 데이터 전송 시 엔티티 바디를 분할하는 기능

### 3.4 Multi Part
하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다. Content-type 헤더 필드 사용
ex) multipart/form-data, multipart/byteranges

### 3.5 Range Request
엔티티의 범위를 지정해서 요청하는 것이며 전체 10,000 바이트 정도의 크기의 리소스에서 5,001~10,000 바이트 범위만 요청할 수 있다.

### 3.6 Contents Negotiation
서버가 제공하는 리소스에 교섭하여 클라이언트에게 더 적합한 리소스를 제공하는 구조<br>
판단 기준: 요청 메시지에 포함 된 헤더 필드의 언어(Accept-Language), 문자 세트(Accept-Charset), 인코딩 방식(Accept-Encoding) 등
<br><br>
## 4장 HTTP 상태 코드
### 4.1 상태코드
요청에 대한 처리 결과가 어떻게 되었는 지 알려주는 상태코드


- 1xx Information 요청 처리 중
- 2xx Success 요청 정상 처리했음
- 3xx Redirection 요청을 완료하기 위해 추가 동작이 필요
- 4xx Client Error 서버는 리퀘스트 이해 불가능
- 5xx Server Error 서버는 리퀘스트 처리 실패



### 4.2 2xx 성공
- 200 OK:  정상처리
- 204 No Content: 처리 성공했으나 응답에 엔티티 바디를 포함하지 않는다. (서버가 돌려 줄 정보가 없을 때 사용)
- 206 Partial Content: Range에 의해서 범위가 지정된 요청에 의해서 서버가 부분적 GET 요청을 받았다. 응답에 Content-Range로 지정된 범위의 엔티티가 포함된다.

### 4.3 3xx 리다이렉트
요청이 정상적으로 처리 종료하기 위해서 브라우저 측에서 특별한 처리를 수행해야 함
- 301 Moved Permanently: 새로운 URI가 부여되었으므로 그 리소스를 참조하는 URI를 사용해야 함
- 302 Found: 301과 비슷하지만 302는 새로운 URI가 일시적인 이동 (301는 영구적인 이동)
- 303 See other: 리다이렉트 장소를 GET 메소드로 얻어야 함

### 4.4 4xx 클라이언트에러
클라이언트의 원인으로 에러 발생
- 400 Bad Request: 리퀘스트 구문이 잘못 됨
- 401 Unauthorized: 송신한 HTTP 인증 정보 필요. 두 번째 부터는 인증 실패를 의미
- 403 Forbidden: 리퀘스트 된 리소스의 액세스가 거부 됨 (권한 문제)
- 404 Not Found: 리퀘스트 한 리소스가 서버상에 없음, 서버 측에 해당 리퀘스트를 거부하고 싶은 이유가 분명하지 않을 때도 이용

### 4.5 5xx 서버 에러
서버 원인으로 에러가 발생
- 500 Internal Server Error: 서버에서 처리 도중 에러 발생 (일시적인 경우도 있음)
- 503 Service Unavailable: 일시적으로 서버가 과부하 상태이거나 점검중이어서 처리 불가능

<br><br>
## 5장 HTTP와 연계하는 웹 서버
### 5.1 가상 호스트
물리적으로 서버가 1대이지만 가상으로 여러 대가 있는 것처럼 설정하여 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있게 한다.<br>
IP는 같으므로 HTTP 요청 시 호스트명과 도메인 명을 완전히 포함한 URI를 지정하거나 Host 헤더 필드에서 지정해야 한다.

### 5.2 프록시, 게이트웨이, 터널
##### 프록시: 서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램
- 기본적인 동작: 클라이언트로 부터 받은 요청을 서버에 전송하고 반대로 서버로부터 응답을 클라이언트에 되돌려 준다.
- 사용 목적
  1) 캐시를 사용해서 네트워크 대역 등을 효율적으로 사용하는 것
  2) 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 철저하게 지키려는  목적

##### 게이트웨이: 다른 서버를 중계하는 서버, 안정성을 높이는 역할
그 다음에 있는 서버가 HTTP 서버 이외의 통신을 하는 서버와 연결한다.

##### 터널: 서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 통신 경로 확립
SSL 같은 암호화 통신을 통해 서버와 안전하게 통신 하기 위해 사용, 리퀘스트 해석하지 않고 그대로 다음 서버에 중계

### 5.3 캐시
##### 캐시
프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스 사본

캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류된다. 결국, 프록시가 서버로부터의 리스폰스를 중계하는 때에 프록시 서버 상에 리소스의 사본을 보존한다.<br>
같은 데이터를 오리진 서버에 반복적으로 전송할 필요가 없어 서버는 같은 요청을 매번 처리 하지 않아도 됨<br>

목적: 리소스를 가진 서버에의 액세스를 줄이는 것이 가능하여 통신량과 통신 시간을 절약할 수 있다.<br>

캐시는 자주 사용하는 데이터나 리소스를 미리 복사해 놓는 임시 장소를 말하고 이러한 임시 장소는 로컬디스크나 서버 등이 될 수 있는데 그 임시 장소가 프록시 서버라면 프록시 캐시가 되는 것. <br>
캐시되어 있는 리소스는 유효기간이 있으므로 오리진 서버에 확인하는 경우가 있다.
<br><br>
## 6장 HTTP 헤더
### 6.1 HTTP 메시지 헤더
메시지 헤더에 클라이언트와 서버 처리에 필요한 정보가 있다. <br>
메시지 바디에 사용자와 리소스를 필요로 하는 정보가 있다.<br>

요청, 응답 모두 HTTP 헤더 필드 존재

### 6.2 HTTP 헤더 필드
헤더 필드의 구조는 '헤더 필드 명 : 필드 값' 으로 구성 `ex) Content-Type: text/html` <br>
일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드

### 6.3 HTTP/1.1 일반 헤더 필드
리퀘스트와 리스폰스 메시지 양쪽에서 사용되는 헤더

### 6.4 리퀘스트 헤더 필드
### 6.5 리스폰스 헤더 필드
### 6.6 엔티티 헤더 필드
### 6.7 쿠키를 위한 헤더 필드
### 6.8 그 이외의 헤더 필드
<br><br>
## 7장 HTTPS
### 7.1 HTTP의 약점
##### 1. 암호화 하지 않은 평문 통신이기 때문에 도청 가능
TCP/IP 구조의 통신 내용은 전부 통신 경로의 도중에 엿볼 수 있다. 
암호화(통신 암호화 - SSL, TLS라는 다른 프로토콜을 조합하여 암호화, 콘텐츠 암호화 - 클라이언트에서 HTTP 메시지를 암호화해서 출력해야 함)

##### 2. 통신 상대를 확인하지 않기 때문에 위장 가능
: URI를 보낸 서버가 URI에서 지정된 호스트인지 아닌지, 클라이언트가 리퀘스트를 출력한 클라이언트인지 아닌지 모름 -> 누구든지 리퀘스트를 보낼 수 있고 리스폰스를 받을 수 있다.
-> SSL로 암호화 + 증명서 이용

##### 3. 완전성(정보의 정확성)을 증명할 수 없기 때문에 변조 가능

### 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS
HTTP의 소켓 부분을 SSL이나 TLS라는 프로토콜로 대체<br>
보통 HTTP는 직접 TCP와 통신하지만 SSL이나 TLS 프로토콜과 통신하도록 대체

SSL은 공개키 암호화 방식을 사용하는 네트워크 보안 기술<br>
공개키로 암호화 비밀키로 복호화<br>

SSL은 HTTP 요청/응답 이외에도 SSL 통신이 추가되기 때문에 통신 속도가 느려지고 암복호화 계산을 위해 CPU나 메모리 등의 리소스를 다량으로 소비함으로써 느리다.
<br><br>
## 8장 인증
### 8.1 인증이란
시스템에 액세스하는 권한을 가졌는 지 패스워드, 원타임 토큰, 증명서 등의 정보로 확인
##### HTTP가 사용하는 인증방법
- BASIC
- DIGEST
- SSL 클라이언트
- 폼 베이스 인증

### 8.2 BASIC 인증
서버가 인증 요청 -> 클라이언트가 Base64 형태로 인코드 한 ID:PWD 데이터 보냄 -> 서버가 인증 확인<br>
Base64는 복호화 가능하므로 노출 가능성, 로그아웃 불가능

### 8.3 DIGEST 인증
챌린지 리스폰스 방식<br>
서버가 클라이언트에게 인증요구 및 챌린지 코드 송신 -> 받은 챌린지 코드를 사용해서 리스폰스 코드 계산 -> 이 값을 서버에게 송신 -> 서버가 인증 정보 확인

### 8.4 SSL 클라이언트 인증
: HTTPS의 클라이언트 인증서를 이용한 인증방법<br>
목적: ID와 PWD가 도난 되었을 때 제 3자가 위장을 하는 경우를 대비하여 SSL 클라이언트 인증 사용<br>
사전에 클라이언트에 클라이언트 증명서를 배포하고 INSTALL 필요 -> 증명서 구입 비용 필요<br>
클라이언트에게 클라이언트 증명서를 요구하는 메시지 송신 -> 유저가 클라이언트 증명서 선택하여 송신 -> 서버가 증명서 검증하여 클라이언트의 공개키 취득 -> HTTPS에 의한 암호 개시<br>

### 8.5 폼 베이스 인증
: 클라이언트가 서버 웹 애플리케이션에 자격 정보를 송신하여 인증하며 웹 애플리케이션에 따라 제공되는 인터페이스나 인증의 방법 다양하며 표준화 X<br>
인증을 성공했던 상태를 유지할 수 없는 스테이스리스 프로토콜인 HTTP를 보충하기 위해 세션관리와 쿠키 사용
<br><br>
## 9장 HTTP에 기능을 추가한 프로토콜
### 9.1 HTTP를 기본으로 하는 프로토콜
### 9.2 HTTP 병목 해소 SPDY
HTTP 병목 현상: 서버 정보가 업데이트 되었는 지 클라이언트가 항상 서버측에 확인해야 하며 불필요한 통신이 발생하게 된다. <br> 
1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다. 리퀘스트는 클라이언트에서만 시작할 수 있고 리스폰스만 받는 것은 불가능하다. 리퀘스트/리스폰스 헤더를 압축하지 않은 채로 보내기 때문에 헤더의 정보가 많을 수록 지연이 심해진다.
<br>
Ajax에 의한 해결: 웹 페이지의 일부만 고쳐 사용할 수 있는 비동기 통신 방법<br>
XMLHttpRequest라는 API로 스크립트 언어로 서버와 HTTP 통신 가능


### 9.3 WebSocket
웹 브라우저가 웹 서버를 위한 양방향 통신 규격이며 HTTP의 병목현상을 해결하기 위해 등장했다. (XMLHttpRequest의 결점 해결) <br>
HTTP의 연결이 클라이언트에 출발점이 있다면, WebSocket은 한 번 접속하면 서버와 클라이언트 어느쪽에서도 송신이 가능하다.
  1) 서버 푸시 기능 (클라이언트에 리퀘스트를 기다리지 않고 데이터 보낼 수 있음)
  2) 한 번 접속하면 오래 유지하기 때문에 통신량이 줄어듦  (handshake 절차 필요 X)

### 9.4 HTTP/2.0
### 9.5 WebDAV
웹 서버 상의 파일 복사, 편집 작업 등의 파일 관리하는 분산 파일 시스템<br>

왜 HTTP를 사용하는가?<br>
많은 기업과 조직의 방화벽 설정과 관련있다. 방화벽은 지정된 프로토콜이나 포트 번호 이외의 패킷은 통과 시키지 않는다. <br> 이로 인해 새로운 프로토콜이나 포트 번호를 이용하는 경우 설정을 변경해야 한다. 
추가로 HTTP 클라이언트인 브라우저가 보급되어 있는 것이나 HTTP 서버가 많이 보급되고 있는 것이 이유이다. 
<br><br>
## 10장 웹 콘텐츠 기술
### 10.1 HTML
웹에서 하이퍼텍스트를 보내기 위해 개발된 언어이다. 하이퍼텍스트는 문서 시스템의 하나로서 링크되어 있는 문서이다. <br> HTML로 쓰여진 문서를 브라우저가 해석해서 렌더링 처리 한 결과가 웹 페이지에 표시된다. 
### 10.2 다이나믹 HTML
웹 페이지를 동적으로 변경하는 다이나믹 HTML<br>
DOM(Document Object Model): HTML, XML 문서를 위한 API이다. DOM을 사용하면 HTML내의 요소를 오브젝트로 다룰 수 있기 때문에 요소 내의 문자열을 추출하거나 CSS를 프로퍼티로서 변경해 디자인을 변경할 수 있다.

### 10.3 웹 애플리케이션
웹을 사용하여 제공되는 프로그램을 지칭한다. 
- 동적 콘텐츠: 프로그램에 의해 생성된 HTML 콘텐츠를 반환한다.
- 정적 콘텐츠: 사전에 준비된 HTML 콘텐츠를 반환한다.
- 서블릿(Servlet): 서버 상에 HTML 등의 동적 콘텐츠를 생성하기 위한 프로그램

### 10.4 데이터 송신에 이용되는 포맷이나 언어
##### XML
목적에 맞게 확장 가능한 범용적으로 사용할 수 있는 마크업 언어이다. 트리구조로 되어 있어 데이터를 구조화하고 추출하는데 용이하다. 
##### RSS, Atom
뉴스나 블로그의 기사 등의 갱신 정보를 송신하기 위한 문서 포맷의 총칭으로 둘다 XML을 이용한다. 
##### JSON
경량 데이터 기술 언어로 JavaScript(ECMAScript)에서 오브젝트 표기법을 바탕으로 한다. 
<br><br>
## 11장 웹 공격 기술
### 11.1 웹 공격 기술
##### 공격 대상
서버, 클라이언트, 웹 애플리케이션의 리소스<br>
  1) 직접 웹 애플리케이션에 액세스하여 서버를 공격하는 능동적 공격
  2)  유저에게 공격 코드를 실행시키는 수동적 공격
  3) 유저가 처한 환경을 이용한 인트라넷 등에 대한 공격
   
HTTP 프로토콜 자체에는 보안 기능이 없다. 따라서 리퀘스트 시 클라이언트에서 변조가 가능하다. <br>


### 11.2 이스케이프 미비로 인한 취약성
웹 애플리케이션의 보안 대책을 실시하는 장소는 1) 클라이언트 2)웹 애플리케이션(서버 측) <br>
크로스 사이트 스크립팅(XSS)/SQL인젝션/OS 커맨드 인잭션/HTTP 헤더 인젝션/디렉토리 접근 공격 리모트 파일 인클루션

### 11.3 웹 서버 설정이나 설계 미비로 인한 취약성
강제 브라우징/부적절한 에러 메시지 처리/오픈 리다이렉트

### 11.4 세션 관리 미비로 인한 취약성
1) 세션 하이잭: 세션 ID를 입수하여 유저로 위장하는 공격
2) 세션 픽세이션: 지정한 세션 ID를 유저에게 강제적으로 사용하게 하는 수동적 공격
3) 크로스 사이트 리퀘스트 포저리: 공격자가 설치해 둔 함정에 의해 개인 정보나 설정 정보등을 강제로 갱신 실행

### 11.5 기타
1) 패스워드 크래킹: 무차별 대입공격, 레인보우 테이블
2) 클릭 재킹: 투명 버튼이나 링크를 심어두고 클릭하게 함으로써 의도하지 않은 콘텐츠에 액세스 시키는 공격
3) DOS공격: 기기나 서버 등을 대상으로 서비스 제공을 정지 상태로 만드는 공격
4) 백도어










